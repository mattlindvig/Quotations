# Quotations Application - Implementation Plan

**Version**: 1.0.0
**Date**: 2025-10-28
**Technology Stack**: React + C# .NET + MongoDB
**Status**: Ready for Implementation

---

## 1. Technology Stack Overview

### 1.1 Frontend
- **Framework**: React 18+
- **Language**: TypeScript
- **State Management**: Redux Toolkit
- **Routing**: React Router v6
- **UI Framework**: Tailwind CSS + shadcn/ui or Material-UI
- **Form Handling**: React Hook Form + Zod validation
- **HTTP Client**: React Query
- **Testing**: Vitest + React Testing Library
- **Build Tool**: Vite

### 1.2 Backend
- **Framework**: ASP.NET Core 8.0 (Web API)
- **Language**: C# 12
- **Architecture**: Clean Architecture / Vertical Slice
- **ORM/ODM**: EF Core
- **Authentication**: ASP.NET Core Identity + JWT
- **Validation**: FluentValidation
- **API Documentation**: Swagger/OpenAPI (Swashbuckle)
- **Testing**: xUnit + FluentAssertions + Moq

### 1.3 Database
- **Primary Database**: MongoDB 7.0+
- **Search**: MongoDB Atlas Search or text indexes
- **Caching**: Redis (optional, for later phases)

### 1.4 DevOps & Infrastructure
- **Version Control**: Git + GitHub
- **CI/CD**: GitHub Actions
- **Containerization**: Docker

---

## 2. Project Structure

### 2.1 Repository Organization

```
Quotations/
├── src/
│   ├── Quotations.Api/              # ASP.NET Core Web API
│   ├── Quotations.Core/             # Domain models, interfaces
│   ├── Quotations.Infrastructure/   # MongoDB, external services
│   ├── Quotations.Application/      # Business logic, CQRS
│   └── Quotations.Tests/            # Unit & integration tests
├── client/
│   ├── src/
│   │   ├── components/              # React components
│   │   ├── features/                # Feature-based modules
│   │   ├── hooks/                   # Custom React hooks
│   │   ├── services/                # API clients
│   │   ├── store/                   # State management
│   │   ├── types/                   # TypeScript types
│   │   ├── utils/                   # Helper functions
│   │   └── App.tsx
│   ├── public/
│   ├── tests/
│   └── package.json
├── docker-compose.yml
├── .github/
│   └── workflows/
│       ├── backend-ci.yml
│       └── frontend-ci.yml
└── README.md
```

### 2.2 Backend Project Structure (Clean Architecture)

```
Quotations.Api/
├── Controllers/
│   ├── QuotesController.cs
│   ├── AuthController.cs
│   ├── ModerationController.cs
│   └── TagsController.cs
├── Middleware/
│   ├── ExceptionHandlerMiddleware.cs
│   └── RateLimitMiddleware.cs
├── Extensions/
│   └── ServiceCollectionExtensions.cs
├── Program.cs
└── appsettings.json

Quotations.Core/
├── Entities/
│   ├── Quote.cs
│   ├── User.cs
│   ├── Tag.cs
│   └── Review.cs
├── Enums/
│   ├── QuoteStatus.cs
│   ├── SourceType.cs
│   └── UserRole.cs
├── Interfaces/
│   ├── IQuoteRepository.cs
│   ├── IUserRepository.cs
│   └── ITagRepository.cs
└── ValueObjects/
    └── QuoteMetadata.cs

Quotations.Application/
├── Commands/
│   ├── CreateQuote/
│   │   ├── CreateQuoteCommand.cs
│   │   ├── CreateQuoteHandler.cs
│   │   └── CreateQuoteValidator.cs
│   └── ReviewQuote/
├── Queries/
│   ├── GetQuotes/
│   │   ├── GetQuotesQuery.cs
│   │   ├── GetQuotesHandler.cs
│   │   └── QuoteDto.cs
│   └── SearchQuotes/
├── Services/
│   ├── DuplicateDetectionService.cs
│   ├── SearchService.cs
│   └── AuthService.cs
└── Mappings/
    └── MappingProfile.cs (AutoMapper)

Quotations.Infrastructure/
├── Data/
│   ├── MongoDbContext.cs
│   ├── MongoDbSettings.cs
│   └── Indexes/
│       └── QuoteIndexes.cs
├── Repositories/
│   ├── QuoteRepository.cs
│   ├── UserRepository.cs
│   └── TagRepository.cs
├── Services/
│   └── EmailService.cs
└── DependencyInjection.cs
```

### 2.3 Frontend Project Structure

```
client/src/
├── components/
│   ├── common/
│   │   ├── Button/
│   │   ├── Input/
│   │   ├── Card/
│   │   └── Modal/
│   ├── layout/
│   │   ├── Header.tsx
│   │   ├── Footer.tsx
│   │   └── Sidebar.tsx
│   └── quotes/
│       ├── QuoteCard.tsx
│       ├── QuoteGrid.tsx
│       ├── QuoteList.tsx
│       └── QuoteDetail.tsx
├── features/
│   ├── quotes/
│   │   ├── QuotesPage.tsx
│   │   ├── hooks/
│   │   │   ├── useQuotes.ts
│   │   │   └── useQuoteFilters.ts
│   │   └── components/
│   │       ├── QuoteFilters.tsx
│   │       └── QuoteSearch.tsx
│   ├── submission/
│   │   ├── SubmitQuotePage.tsx
│   │   ├── QuoteForm.tsx
│   │   └── DuplicateChecker.tsx
│   ├── moderation/
│   │   ├── ModerationQueuePage.tsx
│   │   ├── ReviewPanel.tsx
│   │   └── DuplicateComparison.tsx
│   └── auth/
│       ├── LoginPage.tsx
│       ├── RegisterPage.tsx
│       └── hooks/
│           └── useAuth.ts
├── services/
│   ├── api.ts
│   ├── quoteService.ts
│   ├── authService.ts
│   └── moderationService.ts
├── store/
│   ├── store.ts
│   ├── slices/
│   │   ├── quotesSlice.ts
│   │   ├── authSlice.ts
│   │   └── filtersSlice.ts
│   └── hooks.ts
├── types/
│   ├── quote.ts
│   ├── user.ts
│   └── api.ts
├── utils/
│   ├── formatters.ts
│   ├── validators.ts
│   └── constants.ts
├── hooks/
│   ├── useDebounce.ts
│   ├── usePagination.ts
│   └── useInfiniteScroll.ts
└── App.tsx
```

---

## 3. Database Design (MongoDB)

### 3.1 Collections Schema

#### 3.1.1 Quotes Collection

```javascript
{
  _id: ObjectId,
  text: String,                    // required, indexed
  author: String,                  // required, indexed
  source: String,                  // required
  sourceType: String,              // enum: Book, Movie, Speech, etc.
  date: ISODate,                   // nullable
  context: String,                 // nullable
  sourceDetails: String,           // nullable
  imageUrl: String,                // nullable
  language: String,                // default: "en"
  status: String,                  // enum: Pending, Approved, Rejected
  tags: [                          // array of tag references
    {
      tagId: ObjectId,
      tagName: String              // denormalized for performance
    }
  ],
  metadata: {
    viewCount: Number,             // default: 0
    createdAt: ISODate,
    updatedAt: ISODate,
    createdBy: ObjectId,           // reference to users
    reviewedBy: ObjectId,          // nullable
    reviewedAt: ISODate            // nullable
  }
}

// Indexes
db.quotes.createIndex({ text: "text", author: "text", source: "text" })
db.quotes.createIndex({ author: 1 })
db.quotes.createIndex({ status: 1 })
db.quotes.createIndex({ "tags.tagId": 1 })
db.quotes.createIndex({ sourceType: 1 })
db.quotes.createIndex({ "metadata.createdAt": -1 })
```

#### 3.1.2 Users Collection

```javascript
{
  _id: ObjectId,
  email: String,                   // unique, indexed
  passwordHash: String,
  name: String,
  role: String,                    // enum: User, Moderator, Admin
  emailVerified: Boolean,          // default: false
  profile: {
    bio: String,
    avatarUrl: String
  },
  stats: {
    quotesSubmitted: Number,
    quotesApproved: Number,
    quotesRejected: Number
  },
  metadata: {
    createdAt: ISODate,
    lastLogin: ISODate,
    isActive: Boolean              // default: true
  }
}

// Indexes
db.users.createIndex({ email: 1 }, { unique: true })
db.users.createIndex({ role: 1 })
```

#### 3.1.3 Tags Collection

```javascript
{
  _id: ObjectId,
  name: String,                    // unique
  slug: String,                    // unique, indexed
  description: String,
  parentId: ObjectId,              // nullable, for hierarchy
  metadata: {
    usageCount: Number,            // default: 0
    createdAt: ISODate
  }
}

// Indexes
db.tags.createIndex({ slug: 1 }, { unique: true })
db.tags.createIndex({ name: 1 })
db.tags.createIndex({ parentId: 1 })
```

#### 3.1.4 Reviews Collection

```javascript
{
  _id: ObjectId,
  quoteId: ObjectId,               // reference to quotes
  moderatorId: ObjectId,           // reference to users
  action: String,                  // enum: Approved, Rejected, RevisionRequested
  notes: String,
  edits: {                         // what was changed
    before: Object,
    after: Object
  },
  createdAt: ISODate
}

// Indexes
db.reviews.createIndex({ quoteId: 1 })
db.reviews.createIndex({ moderatorId: 1 })
db.reviews.createIndex({ createdAt: -1 })
```

#### 3.1.5 Duplicates Collection

```javascript
{
  _id: ObjectId,
  quoteId: ObjectId,
  duplicateOfId: ObjectId,
  similarityScore: Number,         // 0.0 - 1.0
  flaggedBy: ObjectId,             // user or system
  status: String,                  // Pending, Confirmed, Dismissed
  createdAt: ISODate
}

// Indexes
db.duplicates.createIndex({ quoteId: 1 })
db.duplicates.createIndex({ duplicateOfId: 1 })
```

---

## 4. Phase 1: MVP Implementation (Weeks 1-12)

### 4.1 Week 1-2: Project Setup & Infrastructure

#### Backend Setup
**Tasks**:
1. Create ASP.NET Core Web API project
2. Set up Clean Architecture solution structure
3. Configure MongoDB connection and settings
4. Implement MongoDbContext and basic configuration
5. Set up dependency injection
6. Configure Swagger/OpenAPI
7. Set up logging (Serilog)
8. Create base repository pattern
9. Set up Docker for local MongoDB

**Deliverables**:
- [ ] Solution structure created
- [ ] MongoDB connection working
- [ ] Swagger UI accessible
- [ ] Docker Compose for local development
- [ ] README with setup instructions

**Testing Requirements**:
- [ ] Integration tests for MongoDB connection
- [ ] Basic health check endpoint

#### Frontend Setup
**Tasks**:
1. Initialize React + TypeScript + Vite project
2. Configure Tailwind CSS
3. Set up React Router
4. Configure Redux Toolkit or Zustand
5. Set up Axios with interceptors
6. Create base layout components
7. Set up environment variables
8. Configure ESLint + Prettier
9. Set up Vitest and React Testing Library

**Deliverables**:
- [ ] React app running
- [ ] Basic routing structure
- [ ] State management configured
- [ ] API client configured
- [ ] Component library decision made

**Testing Requirements**:
- [ ] Sample component tests
- [ ] API service tests (mocked)

### 4.2 Week 3-4: Authentication & User Management

#### Backend Tasks
1. Implement User entity and repository
2. Set up ASP.NET Core Identity with MongoDB
3. Implement JWT authentication
4. Create AuthController (register, login, refresh token)
5. Implement role-based authorization
6. Add authentication middleware
7. Create UserController (profile, update)
8. Implement email verification (stub for now)

**API Endpoints**:
```
POST   /api/auth/register
POST   /api/auth/login
POST   /api/auth/refresh
POST   /api/auth/verify-email
GET    /api/users/me
PUT    /api/users/me
```

**Deliverables**:
- [ ] User registration working
- [ ] Login returns JWT token
- [ ] Token validation middleware
- [ ] Role-based authorization attributes

**Testing Requirements**:
- [ ] Unit tests for AuthService
- [ ] Integration tests for auth endpoints
- [ ] Test token generation and validation
- [ ] Test role-based access

#### Frontend Tasks
1. Create auth slice/store
2. Implement LoginPage component
3. Implement RegisterPage component
4. Create PrivateRoute component
5. Implement auth hooks (useAuth)
6. Add token storage (localStorage + HttpOnly cookies)
7. Implement automatic token refresh
8. Create protected route guards

**Deliverables**:
- [ ] Login/Register forms functional
- [ ] Token stored securely
- [ ] Protected routes working
- [ ] Auto-redirect on auth state change

**Testing Requirements**:
- [ ] Test auth flows
- [ ] Test protected route behavior
- [ ] Test token refresh logic

### 4.3 Week 5-6: Quote Display & Search

#### Backend Tasks
1. Implement Quote entity and repository
2. Create QuotesController with GET endpoints
3. Implement GetQuotesQuery with pagination
4. Add filtering by status, author, sourceType, tags
5. Implement text search using MongoDB text indexes
6. Add sorting options
7. Implement GetQuoteByIdQuery
8. Create GetRandomQuoteQuery
9. Implement caching for frequently accessed quotes

**API Endpoints**:
```
GET    /api/quotes?page=1&limit=20&search=&author=&sourceType=&tags=&sort=
GET    /api/quotes/{id}
GET    /api/quotes/random
```

**Deliverables**:
- [ ] Quote retrieval with pagination
- [ ] Full-text search working
- [ ] Filtering by multiple criteria
- [ ] Sorting options implemented

**Testing Requirements**:
- [ ] Unit tests for QuoteRepository
- [ ] Integration tests for all endpoints
- [ ] Test pagination edge cases
- [ ] Test search accuracy
- [ ] Performance tests for large datasets

#### Frontend Tasks
1. Create Quote types/interfaces
2. Implement quoteService API client
3. Create QuoteCard component
4. Create QuoteGrid component
5. Implement QuotesPage with pagination
6. Add QuoteSearch component
7. Implement QuoteFilters component
8. Create useQuotes hook with React Query
9. Add loading and error states
10. Implement QuoteDetail modal/page

**Deliverables**:
- [ ] Quote cards rendering correctly
- [ ] Pagination working
- [ ] Search functional
- [ ] Filters applying correctly
- [ ] Responsive design on all devices

**Testing Requirements**:
- [ ] Component tests for QuoteCard
- [ ] Integration tests for QuotesPage
- [ ] Test filter combinations
- [ ] Test search debouncing

### 4.4 Week 7-8: Quote Submission

#### Backend Tasks
1. Implement CreateQuoteCommand and handler
2. Add FluentValidation rules
3. Create submission validation logic
4. Implement basic duplicate detection algorithm
5. Create CheckDuplicatesQuery
6. Add quote submission endpoint
7. Implement user's submissions endpoint
8. Add update/delete for pending quotes

**API Endpoints**:
```
POST   /api/quotes
GET    /api/quotes/my-submissions
PUT    /api/quotes/{id}          (only if pending & owned)
DELETE /api/quotes/{id}          (only if pending & owned)
POST   /api/quotes/check-duplicates
```

**Duplicate Detection Algorithm**:
```csharp
public class DuplicateDetectionService
{
    public async Task<List<Quote>> FindSimilarQuotes(string text, string author)
    {
        // 1. Normalize text (lowercase, remove punctuation)
        // 2. Use MongoDB text search for initial candidates
        // 3. Calculate Levenshtein distance for top results
        // 4. Return matches with similarity > 0.8
    }
}
```

**Deliverables**:
- [ ] Quote submission endpoint working
- [ ] Validation errors returned clearly
- [ ] Duplicate detection functional
- [ ] User can view their submissions

**Testing Requirements**:
- [ ] Unit tests for CreateQuoteHandler
- [ ] Test validation rules
- [ ] Test duplicate detection accuracy
- [ ] Integration tests for submission flow

#### Frontend Tasks
1. Create SubmitQuotePage
2. Implement QuoteForm with React Hook Form
3. Add Zod validation schema
4. Implement DuplicateChecker component
5. Add real-time duplicate checking
6. Create MySubmissionsPage
7. Add edit/delete for pending quotes
8. Implement form auto-save to localStorage

**Deliverables**:
- [ ] Submission form with all fields
- [ ] Client-side validation
- [ ] Real-time duplicate warnings
- [ ] User can manage their submissions

**Testing Requirements**:
- [ ] Test form validation
- [ ] Test duplicate detection UI
- [ ] Test edit/delete functionality

### 4.5 Week 9-10: Moderation System

#### Backend Tasks
1. Implement GetModerationQueueQuery
2. Create ReviewQuoteCommand and handler
3. Add moderation endpoints
4. Implement review actions (approve, reject, request revision)
5. Create Review entity and repository
6. Add moderator-only endpoints protection
7. Implement notification system (stub)
8. Add moderation statistics endpoint

**API Endpoints**:
```
GET    /api/moderation/queue?status=pending&page=1
GET    /api/moderation/quote/{id}
POST   /api/moderation/review/{id}
GET    /api/moderation/stats
PUT    /api/quotes/{id}/edit       (moderator override)
```

**Review Workflow**:
```
Pending → Under Review → Approved/Rejected/Revision Requested
                       ↓
                  (if revised) → Pending
```

**Deliverables**:
- [ ] Moderation queue endpoint
- [ ] Review actions functional
- [ ] Reviews tracked in database
- [ ] Moderator analytics available

**Testing Requirements**:
- [ ] Unit tests for ReviewQuoteHandler
- [ ] Integration tests for moderation flow
- [ ] Test state transitions
- [ ] Test authorization (only moderators)

#### Frontend Tasks
1. Create ModerationQueuePage
2. Implement ReviewPanel component
3. Add DuplicateComparison component
4. Create moderation filters
5. Implement bulk actions UI
6. Add review form with notes
7. Create moderation dashboard
8. Implement role-based UI rendering

**Deliverables**:
- [ ] Moderation queue displaying pending quotes
- [ ] Review interface functional
- [ ] Duplicate comparison view
- [ ] Only visible to moderators

**Testing Requirements**:
- [ ] Test moderation actions
- [ ] Test role-based access
- [ ] Test bulk operations

### 4.6 Week 11-12: Tag Management & Polish

#### Backend Tasks
1. Implement Tag entity and repository
2. Create GetTagsQuery (with hierarchy)
3. Implement CreateTagCommand
4. Add tag management endpoints
5. Implement tag usage counting
6. Create tag suggestion algorithm
7. Add tag merging functionality
8. Optimize quote-tag relationships

**API Endpoints**:
```
GET    /api/tags
GET    /api/tags/{id}
POST   /api/tags                  (moderator)
PUT    /api/tags/{id}             (moderator)
DELETE /api/tags/{id}             (moderator)
POST   /api/tags/merge            (moderator)
```

**Deliverables**:
- [ ] Tag CRUD operations
- [ ] Tag hierarchy support
- [ ] Tag suggestions working
- [ ] Tag counts accurate

**Testing Requirements**:
- [ ] Unit tests for tag operations
- [ ] Test tag hierarchy queries
- [ ] Test tag merging logic

#### Frontend Tasks
1. Create TagSelector component
2. Implement TagManagementPage (moderators)
3. Add tag autocomplete
4. Implement tag filters with counts
5. Create tag hierarchy display
6. Add responsive design polish
7. Implement accessibility improvements
8. Add loading skeletons
9. Optimize performance (lazy loading, memoization)
10. Add error boundaries

**Deliverables**:
- [ ] Tag selection intuitive
- [ ] Tag management UI for moderators
- [ ] All pages responsive
- [ ] Accessibility compliant
- [ ] Performance optimized

**Testing Requirements**:
- [ ] Test tag selection
- [ ] Test tag management
- [ ] Accessibility audit
- [ ] Performance testing

---

## 5. API Specifications

### 5.1 Core Models (C#)

#### Quote.cs
```csharp
using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;

namespace Quotations.Core.Entities;

public class Quote
{
    [BsonId]
    [BsonRepresentation(BsonType.ObjectId)]
    public string Id { get; set; }

    [BsonRequired]
    public string Text { get; set; }

    [BsonRequired]
    public string Author { get; set; }

    [BsonRequired]
    public string Source { get; set; }

    [BsonRequired]
    public SourceType SourceType { get; set; }

    public DateTime? Date { get; set; }

    public string? Context { get; set; }

    public string? SourceDetails { get; set; }

    public string? ImageUrl { get; set; }

    public string Language { get; set; } = "en";

    public QuoteStatus Status { get; set; } = QuoteStatus.Pending;

    public List<QuoteTag> Tags { get; set; } = new();

    public QuoteMetadata Metadata { get; set; } = new();
}

public class QuoteTag
{
    [BsonRepresentation(BsonType.ObjectId)]
    public string TagId { get; set; }

    public string TagName { get; set; }
}

public class QuoteMetadata
{
    public int ViewCount { get; set; }

    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    [BsonRepresentation(BsonType.ObjectId)]
    public string CreatedBy { get; set; }

    [BsonRepresentation(BsonType.ObjectId)]
    public string? ReviewedBy { get; set; }

    public DateTime? ReviewedAt { get; set; }
}

public enum QuoteStatus
{
    Pending,
    Approved,
    Rejected,
    RevisionRequested
}

public enum SourceType
{
    Book,
    Movie,
    Speech,
    Interview,
    Article,
    SocialMedia,
    Podcast,
    TvShow,
    Play,
    Song,
    Other
}
```

#### User.cs
```csharp
namespace Quotations.Core.Entities;

public class User
{
    [BsonId]
    [BsonRepresentation(BsonType.ObjectId)]
    public string Id { get; set; }

    [BsonRequired]
    public string Email { get; set; }

    [BsonRequired]
    public string PasswordHash { get; set; }

    [BsonRequired]
    public string Name { get; set; }

    public UserRole Role { get; set; } = UserRole.User;

    public bool EmailVerified { get; set; }

    public UserProfile Profile { get; set; } = new();

    public UserStats Stats { get; set; } = new();

    public UserMetadata Metadata { get; set; } = new();
}

public class UserProfile
{
    public string? Bio { get; set; }
    public string? AvatarUrl { get; set; }
}

public class UserStats
{
    public int QuotesSubmitted { get; set; }
    public int QuotesApproved { get; set; }
    public int QuotesRejected { get; set; }
}

public class UserMetadata
{
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime? LastLogin { get; set; }
    public bool IsActive { get; set; } = true;
}

public enum UserRole
{
    User,
    Moderator,
    Admin
}
```

#### Tag.cs
```csharp
namespace Quotations.Core.Entities;

public class Tag
{
    [BsonId]
    [BsonRepresentation(BsonType.ObjectId)]
    public string Id { get; set; }

    [BsonRequired]
    public string Name { get; set; }

    [BsonRequired]
    public string Slug { get; set; }

    public string? Description { get; set; }

    [BsonRepresentation(BsonType.ObjectId)]
    public string? ParentId { get; set; }

    public TagMetadata Metadata { get; set; } = new();
}

public class TagMetadata
{
    public int UsageCount { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}
```

### 5.2 DTOs and Request/Response Models

#### QuoteDto.cs
```csharp
namespace Quotations.Application.Queries.GetQuotes;

public record QuoteDto
{
    public string Id { get; init; }
    public string Text { get; init; }
    public string Author { get; init; }
    public string Source { get; init; }
    public string SourceType { get; init; }
    public DateTime? Date { get; init; }
    public string? Context { get; init; }
    public string? SourceDetails { get; init; }
    public string? ImageUrl { get; init; }
    public List<TagDto> Tags { get; init; }
    public DateTime CreatedAt { get; init; }
    public int ViewCount { get; init; }
}

public record TagDto
{
    public string Id { get; init; }
    public string Name { get; init; }
}
```

#### CreateQuoteRequest.cs
```csharp
namespace Quotations.Application.Commands.CreateQuote;

public record CreateQuoteRequest
{
    public string Text { get; init; }
    public string Author { get; init; }
    public string Source { get; init; }
    public SourceType SourceType { get; init; }
    public DateTime? Date { get; init; }
    public string? Context { get; init; }
    public string? SourceDetails { get; init; }
    public string? ImageUrl { get; init; }
    public List<string> TagIds { get; init; }
    public string? SubmitterNotes { get; init; }
}
```

#### PagedResult.cs
```csharp
namespace Quotations.Application.Common;

public record PagedResult<T>
{
    public List<T> Items { get; init; }
    public int TotalCount { get; init; }
    public int Page { get; init; }
    public int PageSize { get; init; }
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
    public bool HasNextPage => Page < TotalPages;
    public bool HasPreviousPage => Page > 1;
}
```

### 5.3 API Endpoints Summary

```
Authentication
├── POST   /api/auth/register
├── POST   /api/auth/login
├── POST   /api/auth/refresh
└── POST   /api/auth/verify-email

Users
├── GET    /api/users/me
└── PUT    /api/users/me

Quotes (Public)
├── GET    /api/quotes
├── GET    /api/quotes/{id}
└── GET    /api/quotes/random

Quotes (Authenticated)
├── POST   /api/quotes
├── GET    /api/quotes/my-submissions
├── PUT    /api/quotes/{id}
├── DELETE /api/quotes/{id}
└── POST   /api/quotes/check-duplicates

Moderation
├── GET    /api/moderation/queue
├── GET    /api/moderation/quote/{id}
├── POST   /api/moderation/review/{id}
├── GET    /api/moderation/stats
└── PUT    /api/quotes/{id}/edit

Tags
├── GET    /api/tags
├── GET    /api/tags/{id}
├── POST   /api/tags
├── PUT    /api/tags/{id}
├── DELETE /api/tags/{id}
└── POST   /api/tags/merge
```

---

## 6. Frontend Implementation Details

### 6.1 TypeScript Types

#### types/quote.ts
```typescript
export enum SourceType {
  Book = 'Book',
  Movie = 'Movie',
  Speech = 'Speech',
  Interview = 'Interview',
  Article = 'Article',
  SocialMedia = 'SocialMedia',
  Podcast = 'Podcast',
  TvShow = 'TvShow',
  Play = 'Play',
  Song = 'Song',
  Other = 'Other'
}

export enum QuoteStatus {
  Pending = 'Pending',
  Approved = 'Approved',
  Rejected = 'Rejected',
  RevisionRequested = 'RevisionRequested'
}

export interface Tag {
  id: string;
  name: string;
  slug?: string;
  description?: string;
  parentId?: string;
  usageCount?: number;
}

export interface Quote {
  id: string;
  text: string;
  author: string;
  source: string;
  sourceType: SourceType;
  date?: string;
  context?: string;
  sourceDetails?: string;
  imageUrl?: string;
  language: string;
  status: QuoteStatus;
  tags: Tag[];
  metadata: {
    viewCount: number;
    createdAt: string;
    updatedAt: string;
    createdBy: string;
    reviewedBy?: string;
    reviewedAt?: string;
  };
}

export interface QuoteFilters {
  search?: string;
  author?: string;
  sourceType?: SourceType;
  tags?: string[];
  status?: QuoteStatus;
  dateFrom?: string;
  dateTo?: string;
}

export interface QuotesResponse {
  items: Quote[];
  totalCount: number;
  page: number;
  pageSize: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}
```

### 6.2 API Service Layer

#### services/api.ts
```typescript
import axios, { AxiosInstance } from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';

class ApiClient {
  private client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: API_BASE_URL,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    // Request interceptor for adding auth token
    this.client.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('accessToken');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor for handling token refresh
    this.client.interceptors.response.use(
      (response) => response,
      async (error) => {
        const originalRequest = error.config;

        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;

          try {
            const refreshToken = localStorage.getItem('refreshToken');
            const response = await axios.post(`${API_BASE_URL}/auth/refresh`, {
              refreshToken
            });

            const { accessToken } = response.data;
            localStorage.setItem('accessToken', accessToken);

            originalRequest.headers.Authorization = `Bearer ${accessToken}`;
            return this.client(originalRequest);
          } catch (refreshError) {
            // Refresh failed, redirect to login
            localStorage.removeItem('accessToken');
            localStorage.removeItem('refreshToken');
            window.location.href = '/login';
            return Promise.reject(refreshError);
          }
        }

        return Promise.reject(error);
      }
    );
  }

  public get<T>(url: string, params?: any) {
    return this.client.get<T>(url, { params });
  }

  public post<T>(url: string, data?: any) {
    return this.client.post<T>(url, data);
  }

  public put<T>(url: string, data?: any) {
    return this.client.put<T>(url, data);
  }

  public delete<T>(url: string) {
    return this.client.delete<T>(url);
  }
}

export const apiClient = new ApiClient();
```

#### services/quoteService.ts
```typescript
import { apiClient } from './api';
import { Quote, QuoteFilters, QuotesResponse } from '../types/quote';

export const quoteService = {
  getQuotes: async (filters: QuoteFilters & { page?: number; pageSize?: number }) => {
    const response = await apiClient.get<QuotesResponse>('/quotes', filters);
    return response.data;
  },

  getQuoteById: async (id: string) => {
    const response = await apiClient.get<Quote>(`/quotes/${id}`);
    return response.data;
  },

  getRandomQuote: async () => {
    const response = await apiClient.get<Quote>('/quotes/random');
    return response.data;
  },

  createQuote: async (data: Partial<Quote>) => {
    const response = await apiClient.post<Quote>('/quotes', data);
    return response.data;
  },

  checkDuplicates: async (text: string, author: string) => {
    const response = await apiClient.post<Quote[]>('/quotes/check-duplicates', {
      text,
      author
    });
    return response.data;
  },

  getMySubmissions: async () => {
    const response = await apiClient.get<Quote[]>('/quotes/my-submissions');
    return response.data;
  },

  updateQuote: async (id: string, data: Partial<Quote>) => {
    const response = await apiClient.put<Quote>(`/quotes/${id}`, data);
    return response.data;
  },

  deleteQuote: async (id: string) => {
    await apiClient.delete(`/quotes/${id}`);
  }
};
```

### 6.3 State Management (Redux Toolkit)

#### store/slices/quotesSlice.ts
```typescript
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { quoteService } from '../../services/quoteService';
import { Quote, QuoteFilters, QuotesResponse } from '../../types/quote';

interface QuotesState {
  quotes: Quote[];
  currentQuote: Quote | null;
  filters: QuoteFilters;
  pagination: {
    page: number;
    pageSize: number;
    totalCount: number;
    totalPages: number;
  };
  loading: boolean;
  error: string | null;
}

const initialState: QuotesState = {
  quotes: [],
  currentQuote: null,
  filters: {},
  pagination: {
    page: 1,
    pageSize: 20,
    totalCount: 0,
    totalPages: 0
  },
  loading: false,
  error: null
};

export const fetchQuotes = createAsyncThunk(
  'quotes/fetchQuotes',
  async (params: { filters?: QuoteFilters; page?: number; pageSize?: number }) => {
    return await quoteService.getQuotes({
      ...params.filters,
      page: params.page,
      pageSize: params.pageSize
    });
  }
);

export const fetchQuoteById = createAsyncThunk(
  'quotes/fetchQuoteById',
  async (id: string) => {
    return await quoteService.getQuoteById(id);
  }
);

const quotesSlice = createSlice({
  name: 'quotes',
  initialState,
  reducers: {
    setFilters: (state, action: PayloadAction<QuoteFilters>) => {
      state.filters = action.payload;
      state.pagination.page = 1; // Reset to first page on filter change
    },
    clearFilters: (state) => {
      state.filters = {};
      state.pagination.page = 1;
    },
    setPage: (state, action: PayloadAction<number>) => {
      state.pagination.page = action.payload;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchQuotes.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchQuotes.fulfilled, (state, action) => {
        state.loading = false;
        state.quotes = action.payload.items;
        state.pagination = {
          page: action.payload.page,
          pageSize: action.payload.pageSize,
          totalCount: action.payload.totalCount,
          totalPages: action.payload.totalPages
        };
      })
      .addCase(fetchQuotes.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to fetch quotes';
      })
      .addCase(fetchQuoteById.fulfilled, (state, action) => {
        state.currentQuote = action.payload;
      });
  }
});

export const { setFilters, clearFilters, setPage } = quotesSlice.actions;
export default quotesSlice.reducer;
```

### 6.4 Custom Hooks

#### hooks/useQuotes.ts
```typescript
import { useEffect } from 'react';
import { useAppDispatch, useAppSelector } from '../store/hooks';
import { fetchQuotes, setFilters, setPage } from '../store/slices/quotesSlice';
import { QuoteFilters } from '../types/quote';

export const useQuotes = () => {
  const dispatch = useAppDispatch();
  const { quotes, filters, pagination, loading, error } = useAppSelector(
    (state) => state.quotes
  );

  useEffect(() => {
    dispatch(fetchQuotes({ filters, page: pagination.page, pageSize: pagination.pageSize }));
  }, [dispatch, filters, pagination.page, pagination.pageSize]);

  const updateFilters = (newFilters: QuoteFilters) => {
    dispatch(setFilters(newFilters));
  };

  const changePage = (page: number) => {
    dispatch(setPage(page));
  };

  return {
    quotes,
    filters,
    pagination,
    loading,
    error,
    updateFilters,
    changePage
  };
};
```

---

## 7. Testing Strategy

### 7.1 Backend Testing

#### Unit Tests Example (xUnit)
```csharp
using Xunit;
using FluentAssertions;
using Moq;
using Quotations.Application.Commands.CreateQuote;
using Quotations.Core.Interfaces;

public class CreateQuoteHandlerTests
{
    private readonly Mock<IQuoteRepository> _quoteRepositoryMock;
    private readonly Mock<IDuplicateDetectionService> _duplicateServiceMock;
    private readonly CreateQuoteHandler _handler;

    public CreateQuoteHandlerTests()
    {
        _quoteRepositoryMock = new Mock<IQuoteRepository>();
        _duplicateServiceMock = new Mock<IDuplicateDetectionService>();
        _handler = new CreateQuoteHandler(
            _quoteRepositoryMock.Object,
            _duplicateServiceMock.Object
        );
    }

    [Fact]
    public async Task Handle_ValidQuote_CreatesQuote()
    {
        // Arrange
        var command = new CreateQuoteCommand
        {
            Text = "Test quote",
            Author = "Test Author",
            Source = "Test Book",
            SourceType = SourceType.Book,
            TagIds = new List<string> { "tag1" }
        };

        _duplicateServiceMock
            .Setup(x => x.FindSimilarQuotes(It.IsAny<string>(), It.IsAny<string>()))
            .ReturnsAsync(new List<Quote>());

        // Act
        var result = await _handler.Handle(command, CancellationToken.None);

        // Assert
        result.Should().NotBeNull();
        result.Status.Should().Be(QuoteStatus.Pending);
        _quoteRepositoryMock.Verify(x => x.CreateAsync(It.IsAny<Quote>()), Times.Once);
    }

    [Fact]
    public async Task Handle_QuoteTextTooShort_ThrowsValidationException()
    {
        // Arrange
        var command = new CreateQuoteCommand
        {
            Text = "Short",
            Author = "Test Author",
            Source = "Test Book",
            SourceType = SourceType.Book
        };

        var validator = new CreateQuoteValidator();

        // Act
        var result = await validator.ValidateAsync(command);

        // Assert
        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contain(e => e.PropertyName == nameof(command.Text));
    }
}
```

#### Integration Tests Example
```csharp
using Microsoft.AspNetCore.Mvc.Testing;
using Xunit;
using System.Net.Http.Json;

public class QuotesControllerIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;

    public QuotesControllerIntegrationTests(WebApplicationFactory<Program> factory)
    {
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task GetQuotes_ReturnsSuccessStatusCode()
    {
        // Act
        var response = await _client.GetAsync("/api/quotes");

        // Assert
        response.EnsureSuccessStatusCode();

        var quotes = await response.Content.ReadFromJsonAsync<PagedResult<QuoteDto>>();
        quotes.Should().NotBeNull();
    }

    [Fact]
    public async Task CreateQuote_WithoutAuth_ReturnsUnauthorized()
    {
        // Arrange
        var newQuote = new CreateQuoteRequest
        {
            Text = "Test quote",
            Author = "Author",
            Source = "Source",
            SourceType = SourceType.Book,
            TagIds = new List<string>()
        };

        // Act
        var response = await _client.PostAsJsonAsync("/api/quotes", newQuote);

        // Assert
        response.StatusCode.Should().Be(System.Net.HttpStatusCode.Unauthorized);
    }
}
```

### 7.2 Frontend Testing

#### Component Tests (Vitest + React Testing Library)
```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import { QuoteCard } from './QuoteCard';
import { Quote } from '../types/quote';

describe('QuoteCard', () => {
  const mockQuote: Quote = {
    id: '1',
    text: 'Test quote text',
    author: 'Test Author',
    source: 'Test Source',
    sourceType: 'Book',
    language: 'en',
    status: 'Approved',
    tags: [
      { id: '1', name: 'Inspiration' },
      { id: '2', name: 'Wisdom' }
    ],
    metadata: {
      viewCount: 100,
      createdAt: '2025-01-01',
      updatedAt: '2025-01-01',
      createdBy: 'user1'
    }
  };

  it('renders quote text correctly', () => {
    render(<QuoteCard quote={mockQuote} />);

    expect(screen.getByText('Test quote text')).toBeInTheDocument();
  });

  it('displays author and source', () => {
    render(<QuoteCard quote={mockQuote} />);

    expect(screen.getByText(/Test Author/)).toBeInTheDocument();
    expect(screen.getByText(/Test Source/)).toBeInTheDocument();
  });

  it('renders all tags', () => {
    render(<QuoteCard quote={mockQuote} />);

    expect(screen.getByText('Inspiration')).toBeInTheDocument();
    expect(screen.getByText('Wisdom')).toBeInTheDocument();
  });

  it('calls onShare when share button is clicked', async () => {
    const onShare = vi.fn();
    render(<QuoteCard quote={mockQuote} onShare={onShare} />);

    const shareButton = screen.getByRole('button', { name: /share/i });
    fireEvent.click(shareButton);

    await waitFor(() => {
      expect(onShare).toHaveBeenCalledWith(mockQuote);
    });
  });
});
```

#### Hook Tests
```typescript
import { renderHook, waitFor } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import { useQuotes } from './useQuotes';
import { quoteService } from '../services/quoteService';

vi.mock('../services/quoteService');

describe('useQuotes', () => {
  it('fetches quotes on mount', async () => {
    const mockQuotes = {
      items: [{ id: '1', text: 'Test' }],
      totalCount: 1,
      page: 1,
      pageSize: 20,
      totalPages: 1,
      hasNextPage: false,
      hasPreviousPage: false
    };

    vi.mocked(quoteService.getQuotes).mockResolvedValue(mockQuotes);

    const { result } = renderHook(() => useQuotes());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.quotes).toHaveLength(1);
    expect(quoteService.getQuotes).toHaveBeenCalled();
  });
});
```

---

## 8. Configuration Files

### 8.1 Backend Configuration

#### appsettings.json
```json
{
  "MongoDbSettings": {
    "ConnectionString": "mongodb://localhost:27017",
    "DatabaseName": "QuotationsDb"
  },
  "JwtSettings": {
    "SecretKey": "your-secret-key-min-32-characters-long",
    "Issuer": "QuotationsApi",
    "Audience": "QuotationsClient",
    "ExpiryMinutes": 60,
    "RefreshTokenExpiryDays": 7
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "CorsOrigins": [
    "http://localhost:5173",
    "http://localhost:3000"
  ]
}
```

#### Program.cs
```csharp
using Quotations.Infrastructure;
using Quotations.Application;
using Microsoft.OpenApi.Models;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "Quotations API", Version = "v1" });

    // JWT Authentication
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Description = "JWT Authorization header using the Bearer scheme",
        Name = "Authorization",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.ApiKey,
        Scheme = "Bearer"
    });

    c.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            Array.Empty<string>()
        }
    });
});

// Configure MongoDB
builder.Services.AddInfrastructure(builder.Configuration);
builder.Services.AddApplication();

// Configure CORS
var corsOrigins = builder.Configuration.GetSection("CorsOrigins").Get<string[]>();
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowFrontend", policy =>
    {
        policy.WithOrigins(corsOrigins)
              .AllowAnyMethod()
              .AllowAnyHeader()
              .AllowCredentials();
    });
});

var app = builder.Build();

// Configure middleware pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseCors("AllowFrontend");
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

app.Run();
```

### 8.2 Frontend Configuration

#### vite.config.ts
```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  },
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true
      }
    }
  }
});
```

#### tailwind.config.js
```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: '#3B82F6',
        secondary: '#6B7280',
        accent: '#F59E0B'
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif'],
        serif: ['Georgia', 'Times New Roman', 'serif']
      }
    },
  },
  plugins: [],
  darkMode: 'class'
}
```

#### package.json
```json
{
  "name": "quotations-client",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "format": "prettier --write \"src/**/*.{ts,tsx,css}\""
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.20.0",
    "@reduxjs/toolkit": "^2.0.0",
    "react-redux": "^9.0.0",
    "axios": "^1.6.0",
    "@tanstack/react-query": "^5.12.0",
    "react-hook-form": "^7.48.0",
    "zod": "^3.22.0",
    "@hookform/resolvers": "^3.3.0",
    "date-fns": "^2.30.0",
    "clsx": "^2.0.0",
    "lucide-react": "^0.294.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@vitejs/plugin-react": "^4.2.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0",
    "vitest": "^1.0.0",
    "@testing-library/react": "^14.1.0",
    "@testing-library/jest-dom": "^6.1.0",
    "@testing-library/user-event": "^14.5.0",
    "@vitest/ui": "^1.0.0",
    "tailwindcss": "^3.3.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0",
    "eslint": "^8.55.0",
    "prettier": "^3.1.0"
  }
}
```

---

## 9. Deployment Strategy

### 9.1 Docker Setup

#### docker-compose.yml (Development)
```yaml
version: '3.8'

services:
  mongodb:
    image: mongo:7.0
    container_name: quotations-mongo
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: password
      MONGO_INITDB_DATABASE: QuotationsDb
    volumes:
      - mongo-data:/data/db
      - ./init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js

  api:
    build:
      context: ./src
      dockerfile: Quotations.Api/Dockerfile
    container_name: quotations-api
    ports:
      - "5000:80"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - MongoDbSettings__ConnectionString=mongodb://admin:password@mongodb:27017
      - MongoDbSettings__DatabaseName=QuotationsDb
    depends_on:
      - mongodb

  client:
    build:
      context: ./client
      dockerfile: Dockerfile
    container_name: quotations-client
    ports:
      - "5173:80"
    environment:
      - VITE_API_URL=http://localhost:5000/api
    depends_on:
      - api

volumes:
  mongo-data:
```

#### Dockerfile (Backend)
```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

COPY ["Quotations.Api/Quotations.Api.csproj", "Quotations.Api/"]
COPY ["Quotations.Application/Quotations.Application.csproj", "Quotations.Application/"]
COPY ["Quotations.Core/Quotations.Core.csproj", "Quotations.Core/"]
COPY ["Quotations.Infrastructure/Quotations.Infrastructure.csproj", "Quotations.Infrastructure/"]

RUN dotnet restore "Quotations.Api/Quotations.Api.csproj"

COPY . .
WORKDIR "/src/Quotations.Api"
RUN dotnet build "Quotations.Api.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "Quotations.Api.csproj" -c Release -o /app/publish

FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS final
WORKDIR /app
COPY --from=publish /app/publish .
EXPOSE 80
ENTRYPOINT ["dotnet", "Quotations.Api.dll"]
```

#### Dockerfile (Frontend)
```dockerfile
FROM node:20-alpine AS build
WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 9.2 CI/CD Pipeline (GitHub Actions)

#### .github/workflows/backend-ci.yml
```yaml
name: Backend CI/CD

on:
  push:
    branches: [main, develop]
    paths:
      - 'src/**'
  pull_request:
    branches: [main, develop]
    paths:
      - 'src/**'

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: dotnet restore ./src/Quotations.sln

      - name: Build
        run: dotnet build ./src/Quotations.sln --no-restore --configuration Release

      - name: Run tests
        run: dotnet test ./src/Quotations.sln --no-build --configuration Release --verbosity normal --collect:"XPlat Code Coverage"

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.xml

  build-and-push:
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Build Docker image
        run: docker build -t quotations-api:latest ./src

      # Add deployment steps here (Azure, AWS, etc.)
```

#### .github/workflows/frontend-ci.yml
```yaml
name: Frontend CI/CD

on:
  push:
    branches: [main, develop]
    paths:
      - 'client/**'
  pull_request:
    branches: [main, develop]
    paths:
      - 'client/**'

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: client/package-lock.json

      - name: Install dependencies
        working-directory: ./client
        run: npm ci

      - name: Lint
        working-directory: ./client
        run: npm run lint

      - name: Type check
        working-directory: ./client
        run: npx tsc --noEmit

      - name: Run tests
        working-directory: ./client
        run: npm run test:coverage

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./client/coverage/coverage-final.json

  build:
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install and build
        working-directory: ./client
        run: |
          npm ci
          npm run build

      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: ./client
```

---

## 10. Success Criteria & Milestones

### 10.1 Phase 1 MVP Success Criteria

**Functional Requirements** (All must pass):
- [ ] User can browse approved quotes
- [ ] Search returns relevant results within 300ms
- [ ] Filters work correctly (author, source type, tags)
- [ ] Registered users can submit quotes
- [ ] Duplicate detection flags >80% similar quotes
- [ ] Moderators can approve/reject submissions
- [ ] All pages responsive on mobile/tablet/desktop
- [ ] Accessibility audit passes WCAG 2.1 AA

**Technical Requirements**:
- [ ] 80%+ test coverage (backend and frontend)
- [ ] All API endpoints documented in Swagger
- [ ] CI/CD pipeline running successfully
- [ ] Application deployable via Docker
- [ ] Performance: Page load <2s, API responses <500ms

**Content Requirements**:
- [ ] Minimum 100 approved quotes in database
- [ ] At least 5 active users with submissions
- [ ] Tag hierarchy with 20+ tags established

### 10.2 Key Performance Indicators (KPIs)

**Phase 1 (Weeks 1-12)**:
- Zero critical bugs in production
- 95%+ uptime
- All core features functional
- Positive feedback from 5 beta users

**Phase 2 (Weeks 13-18)**:
- 500+ quotes in database
- 50+ registered users
- 90%+ approval rate for submissions
- <5% duplicate submissions

**Phase 3 (Weeks 19-26)**:
- 1000+ quotes
- 200+ registered users
- User engagement: 3+ quotes viewed per session
- Search usage: 50%+ of sessions

---

## 11. Risk Mitigation

### 11.1 Technical Risks

**Risk**: MongoDB text search insufficient for large collections
**Mitigation**: Implement MongoDB Atlas Search or ElasticSearch in Phase 2
**Monitoring**: Track search response times, set alert at >500ms

**Risk**: Duplicate detection false positives
**Mitigation**: Tunable similarity threshold, manual override option
**Monitoring**: Track false positive rate, adjust algorithm

**Risk**: Performance degradation with scale
**Mitigation**: Implement caching (Redis), database indexing, pagination
**Monitoring**: Regular performance testing, APM tools

### 11.2 Product Risks

**Risk**: Low quality submissions
**Mitigation**: Robust moderation tools, automated checks, clear guidelines
**Monitoring**: Track approval/rejection ratios

**Risk**: Insufficient moderator capacity
**Mitigation**: Gamification, batch tools, semi-automated approvals
**Monitoring**: Average review time, queue length

**Risk**: Copyright/attribution issues
**Mitigation**: Clear ToS, DMCA process, source verification
**Monitoring**: User reports, legal review

---

## 12. Next Steps

### Immediate Actions (Week 1)

1. **Repository Setup**:
   - [ ] Create GitHub repository
   - [ ] Initialize .NET solution with Clean Architecture
   - [ ] Initialize React project with Vite
   - [ ] Set up project structure

2. **Development Environment**:
   - [ ] Set up MongoDB Atlas account (or local MongoDB)
   - [ ] Configure Docker Compose for local development
   - [ ] Install necessary tools and SDKs
   - [ ] Create development branch strategy

3. **Documentation**:
   - [ ] Create detailed README with setup instructions
   - [ ] Document coding standards
   - [ ] Set up issue templates
   - [ ] Create PR template

4. **Team Alignment**:
   - [ ] Review specification with stakeholders
   - [ ] Assign roles and responsibilities
   - [ ] Set up communication channels
   - [ ] Schedule weekly sprint planning

---

## Appendix A: Technology Justifications

### Why React?
- **Component-based**: Reusable UI components align with DRY principle
- **Ecosystem**: Rich library ecosystem for forms, state, routing
- **TypeScript**: Strong typing prevents runtime errors
- **Performance**: Virtual DOM for efficient rendering

### Why C# .NET?
- **Type Safety**: Strong typing catches errors at compile time
- **Performance**: Excellent for API workloads
- **Ecosystem**: Mature libraries for auth, validation, testing
- **MongoDB Driver**: Official driver with full feature support

### Why MongoDB?
- **Flexible Schema**: Easy to evolve quote metadata
- **Performance**: Fast queries with proper indexing
- **Full-Text Search**: Built-in text search capabilities
- **Scalability**: Horizontal scaling with sharding
- **Document Model**: Natural fit for quote structure

---

## Appendix B: Glossary

- **Clean Architecture**: Architectural pattern separating concerns into layers
- **CQRS**: Command Query Responsibility Segregation pattern
- **JWT**: JSON Web Token for stateless authentication
- **ODM**: Object-Document Mapper for MongoDB
- **MongoDB Atlas**: Cloud-hosted MongoDB service
- **Levenshtein Distance**: Algorithm for measuring string similarity

---

**Document Status**: Ready for Implementation
**Last Updated**: 2025-10-28
**Next Review**: After Phase 1 completion